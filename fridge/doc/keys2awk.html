
<h1>Four Key to Gawk</h1>

<p> by T. Menzies
<p>Imagine Gawk as a kind of a cut-down C language with four tricks:
<ol><li> self-initializing variables <li>pattern-based programming
<li> regular expressions <li> associative arrays.</ol>
<p>What to all these do? Well....

<h2>Self-initializing variables.</h2>

<p>You don't need to define variables- they appear as your use them.</p>

<p>There are only three types: stings, numbers, and arrays.</p>

<p>To ensure a number is a number, add zero to it.</p>

<pre><code>x=x+0
</code></pre>

<p>To ensure a string is a string, add an empty string to it.</p>

<pre><code>x= x "" "the string you really want to add"
</code></pre>

<p>To ensure your variables aren't global, use them within a function and add more variables to the call. For example if a function is passed two variables, define it with two PLUS the local variables:</p>

<pre><code> function haslocals(passed1,passed2,         local1,local2,local3) {
        passed1=passes1+1  # changes externally
        local1=7           # only changed locally
 }
</code></pre>

<p>Note that its good practice to add white space between passed and local variables.</p>

<h2>Pattern-based programming</h2>

<p>Gawk programs can contain functions AND pattern/action pairs.</p>

<p>If the pattern is satisfied, the action is called.</p>

<pre><code> /^\.P1/ { if (p != 0) print ".P1 after .P1, line", NR;
           p = 1;
         }
 /^\.P2/ { if (p != 1) print ".P2 with no preceding .P1, line", NR;
           p = 0;
         }
 END     { if (p != 0) print "missing .P2 at end" }
</code></pre>

<p>Two magic patterns are BEGIN and END. These are true before and after all the input files are read. Use END of end actions (e.g. final reports) and BEGIN for start up actions such as initializing default variables, setting the field separator, resetting the seed of the random number generator:</p>

<pre><code> BEGIN {
        while (getline &lt; "Usr.Dict.Words") #slurp in dictionary 
                dict[$0] = 1
        FS=",";                            #set field seperator
        srand();                           #reset random seed
        Round=10;                          #always start globals with U.C.
 }
</code></pre>

<p>The default action is {print $0}; i.e. print the whole line.</p>

<p>The default pattern is 1; i.e. true.</p>

<p>Patterns are checked, top to bottom, in source-code order.</p>

<p>Patterns can contain regular expressions. In the above example /^\.P1/ means "front of line followed by a full stop followed by P1". 
Regular expressions are important enough for their own section.</p>

<h2>A Small Example</h2>
<p>Ok, so now we know enough to  explain an simple report function.
 How does <b><i>hist.awk</i></b> work
in the following?
<pre><code> 
% cat /etc/passwd | grep -v \# | cut -d: -f 6|sort |
                    uniq -c | sort -r -n | Gawk -f hist.awk

              **************************  26 /var/empty
                                      **   2 /var/virusmails
                                      **   2 /var/root
                                       *   1 /var/xgrid/controller
                                       *   1 /var/xgrid/agent
                                       *   1 /var/teamsserver
                                       *   1 /var/spool/uucp
                                       *   1 /var/spool/postfix
                                       *   1 /var/spool/cups
                                       *   1 /var/pcast/server
                                       *   1 /var/pcast/agent
                                       *   1 /var/imap
                                       *   1 /Library/WebServer
</code></pre>
<p><b><i>hist.awk</i></b> reads
the maximum width from line one (when <b><i>NR==1</i></b>), then scales it to some maximum width value.
For each line, it then 
prints the line (<b><i>$0</i></b>) with some stars at front.

<pre><code>
NR==1  { Width = Width ? Width : 40 ; sets Width if it is missing
         Scale = $1 > Width ? $1 / Width : 1 
       }
       { Stars=int($1*Scale);  
         print str(Width - Stars," ") str(Stars,"*") $0 
       }

# note that, in the following "tmp" is a local variable
function str(n,c, tmp) { # returns a string, size "n", of all  "c" 
    while((n--) > 0 ) tmp= c tmp 
    return tmp 
}
</code></pre>
<h2>Regular Expressions</h2>

<p>Do you know what these mean?</p>

<ul>
<li>/^[ \t\n]*/</li>
<li>/[ \t\n]*$/</li>
<li>/^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$/</li>
</ul>

<p>Well, the first two are leading and trailing blank spaces on a line and the last one is the definition of an IEEE-standard number written as a regular expression. Once we know that, we can do a bunch of common tasks like trimming away white space around a string:</p>

<pre><code>  function trim(s,     t) {
    t=s;
    sub(/^[ \t\n]*/,"",t);
    sub(/[ \t\n]*$/,"",t);
    return t
 }
</code></pre>

<p>or recognize something that isn't a number:</p>

<pre><code>if ( $i !~ /^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$/ ) 
    {print "ERROR: " $i " not a number}
</code></pre>

<p>Regular expressions are an astonishingly useful tool supported
by many languages (e.g. Awk, Perl, Python, Java). The
following notes review the basics. For full details, see
<a href="http://www.gnu.org/manual/Gawk-3.1.1/html_node/Regexp.html#Regexp">http://www.gnu.org/manual/Gawk-3.1.1/html_node/Regexp.html#Regexp</a>.</p>

<p>Syntax: Here's the basic building blocks of regular expressions:</p>

<p><strong>c</strong> <br />
matches the character c (assuming c is a character with no special meaning in regexps).</p>

<p><strong>\c</strong> <br />
matches the literal character c; e.g. tabs and newlines are \t and \n respectively.</p>

<p><strong>.</strong> <br />

matches any character except newline.</p>

<p><strong>^</strong> <br />
matches the beginning of a line or a string.</p>

<p><strong>$</strong> <br />
matches the end of a line or a string.</p>

<p><strong>[abc...]</strong> <br />

matches any of the characters ac... (character class).</p>

<p><strong>[^ac...]</strong> <br />
matches any character except abc... and newline (negated character class).</p>

<p><strong>r*</strong> <br />
matches zero or more r's.</p>

<p>And that's enough to understand our trim function shown above. The regular expression <strong>/[ \t]*$/</strong> means trailing whitespace; i.e. zero-or-more spaces or tabs followed by the end of line.</p>

<h2>More Syntax:</h2>

<p>But that's only the start of regular expressions. There's lots more. For example:</p>

<p><strong>r+</strong> <br />
matches one or more r's.</p>

<p><strong>r?</strong> <br />
matches zero or one r's.</p>

<p><strong>r1|r2</strong> <br />
matches either r1 or r2 (alternation).</p>

<p><strong>r1r2</strong> <br />
matches r1, and then r2 (concatenation).</p>

<p><strong>(r)</strong> <br />
matches r (grouping).</p>

<p>Now we can read <strong>^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$</strong> like this:</p>

<p><strong>^[+-]? ...</strong> <br />
Numbers begin with zero or one plus or minus signs.</p>

<p><strong>...[0-9]+...</strong> <br />
Simple numbers are just one or more numbers.</p>

<p><strong>...[.]?[0-9]*...</strong> <br />
which may be followed by a decimal point and zero or more digits.</p>

<p><strong>...|[.][0-9]+...</strong> <br />
Alternatively, a number can have zero leading numbers and just start with a decimal point.</p>

<p><strong>.... ([eE]...)?$</strong> <br />
Also, there may be an exponent added</p>

<p><strong>...[+-]?[0-9]+)?$</strong> <br />
and that exponent is a positive or negative bunch of digits.</p>

<h2>Associative arrays</h2>

<p>Gawk has arrays, but they are only indexed by strings. This can be very useful, but it can also be annoying. For example, we can count the frequency of words in a document (ignoring the icky part about printing them out):</p>

<pre><code>Gawk '{for(i=1;i &lt;=NF;i++) freq[$i]++ }' filename
</code></pre>

<p>The array will hold an integer value for each word that occurred in the file. Unfortunately, this treats foo'',Foo'', and foo,'' as different words. Oh well. How do we print out these frequencies? Gawk has a specialfor'' construct that loops over the values in an array. This script is longer than most command lines, so it will be expressed as an executable script:</p>

<pre><code> #!/usr/bin/awk -f
  {for(i=1;i &lt;=NF;i++) freq[$i]++ }
  END{for(word in freq) print word, freq[word]  }
</code></pre>

<p>You can find out if an element exists in an array at a certain index with the expression:</p>

<pre><code>index in array
</code></pre>

<p>This expression tests whether or not the particular index exists,
    without the side effect of creating that element if it is not present.</p>

<p>You can remove an individual element of an array using the delete statement:</p>

<pre><code>delete array[index]
</code></pre>

<p>It is not an error to delete an element which does not exist.</p>

<p>Gawk has a special kind of for statement for scanning an array:</p>

<pre><code> for (var in array)
        body

</code></pre>

<p>This loop executes body once for each different value that your program has previously used as an index in array, with the variable var set to that index.</p>

<p>There order in which the array is scanned is not defined.</p>

<p>To scan an array in some numeric order, you need to use keys 1,2,3,... and store somewhere that the array is N long. Then you can do the Here are some useful array functions. We begin with the usual stack stuff. These stacks have items 1,2,3,.... and position 0 is reserved for the size of the stack</p>

<pre><code> function top(a)        {return a[a[0]]}
 function push(a,x,  i) {i=++a[0]; a[i]=x; return i}
 function pop(a,   x,i) {
   i=a[0]--;  
   if (!i) {return ""} else {x=a[i]; delete a[i]; return x}}
</code></pre>

<p>The pop function can be used in the usual way:</p>

<pre><code> BEGIN {push(a,1); push(a,2); push(a,3);
        while(x=pop(a)) print x
 3
 2
 1
</code></pre>

<p>We can catch everything in an array to a string:</p>

<pre><code> function a2s(a,  i,s) {
        s=""; 
        for (i in a) {s=s " " i "= [" a[i]"]\n"}; 
        return s}

  BEGIN {push(L,1); push(L,2); push(L,3);
        print a2s(L);}
  0= [3]
  1= [1]
  2= [2]
  3= [3]
</code></pre>

<p>And we can go the other way and convert a string into an array using the built in split function. These pod files were built using a recursive include function that seeks patterns of the form:</p>

<p>^=include file</p>

<p>This function splits likes on space characters into the array `a' then looks for =include in a[1]. If found, it calls itself recursively on a[2]. Otherwise, it just prints the line:</p>

<pre><code> function rinclude (line,    x,a) {
   split(line,a,/ /);
   if ( a[1] ~ /^\=include/ ) { 
     while ( ( getline x &lt; a[2] ) &gt; 0) rinclude(x);
     close(a[2])}
   else {print line}
 }
</code></pre>

<p>Note that the third argument of the split function can be any regular expression.</p>

<p>By the way, here's a nice trick with arrays. To print the lines in a files in a random order:</p>

<pre><code> BEGIN {srand()}
       {Array[rand()]=$0}
 END   {for(I in Array) print $0}
</code></pre>

<p>Short, heh? This is not a perfect solution. Gawk can only generate
1,000,000 different random numbers so the <a href="http://burtleburtle.net/bob/hash/birthday.html">birthday theorem</a> cautions
that there is a small chance that the lines will be lost when different
lines are written to the same randomly selected location. After some
experiments, I can report that you lose around one item after 1,000
inserts and 10 to 12 items after 10,000 random inserts. Nothing to write
home about really. But for larger item sets, the above three liner is not
what you want to use. For exampl,e 10,000 to 12,000 items (more than 10%)
are lost after 100,000 random inserts. Not good!</p>

